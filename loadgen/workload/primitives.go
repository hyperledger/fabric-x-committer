/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package workload

import (
	"context"
	"io"

	"golang.org/x/time/rate"

	"github.com/hyperledger/fabric-x-committer/utils"
)

// Generator generates new T each time Next() is called.
type Generator[T any] interface {
	Next() T
}

// FloatToIntGenerator wraps a float generator and produces integers.
type FloatToIntGenerator struct {
	FloatGen Generator[float64]
}

// Next yields a new integer.
func (g *FloatToIntGenerator) Next() int {
	return int(g.FloatGen.Next())
}

// FloatToPositiveIntGenerator wraps a float generator and produces positive int (>=1).
type FloatToPositiveIntGenerator struct {
	FloatGen Generator[float64]
}

// Next yields a new integer.
func (g *FloatToPositiveIntGenerator) Next() uint64 {
	return uint64(max(g.FloatGen.Next(), 1))
}

// FloatToBooleanGenerator wraps a float generator and produces boolean (true when >=1).
type FloatToBooleanGenerator struct {
	FloatGen Generator[float64]
}

// Next yields a new integer.
func (g *FloatToBooleanGenerator) Next() bool {
	return int(g.FloatGen.Next()) > 0
}

// ConstGenerator produces a constant value.
type ConstGenerator[T any] struct {
	Const T
}

// Next yields the constant value.
func (g *ConstGenerator[T]) Next() T {
	return g.Const
}

// ByteArrayGenerator generates a random byte array of Size.
type ByteArrayGenerator struct {
	Size   uint32
	Source io.Reader
}

// Next yields a byte array.
func (g *ByteArrayGenerator) Next() []byte {
	if g.Size == 0 {
		return nil
	}
	return utils.MustRead(g.Source, int(g.Size))
}

// MultiGenerator generates an array of size determined by Count, with items generated by Gen.
type MultiGenerator[T any] struct {
	Count Generator[int]
	Gen   Generator[T]
}

// Next yields an array of items.
func (g *MultiGenerator[T]) Next() []T {
	return GenerateArray(g.Gen, g.Count.Next())
}

// RateLimiterGenerator pull batch of values from queue and yield them one by one.
// It limits the generated rate using limiter.
// It will finish once queue is closed.
type RateLimiterGenerator[T any] struct {
	queue   <-chan []T
	limiter *rate.Limiter
	items   []T
}

// NewRateLimiterGenerator create a new instance if RateLimiterGenerator.
func NewRateLimiterGenerator[T any](queue <-chan []T, limiter *rate.Limiter) *RateLimiterGenerator[T] {
	return &RateLimiterGenerator[T]{
		queue:   queue,
		limiter: limiter,
	}
}

// Next yields a value at the required rate.
func (g *RateLimiterGenerator[T]) Next(ctx context.Context) T {
	ret := g.NextN(ctx, 1)
	if len(ret) == 0 {
		return *new(T)
	}
	return ret[0]
}

// NextN returns the next N values from the generator.
func (g *RateLimiterGenerator[T]) NextN(ctx context.Context, size int) []T {
	if g.queue == nil {
		return nil
	}

	var fetchedCount int
	for len(g.items) < size {
		newBatch, ok := <-g.queue
		if !ok || len(newBatch) == 0 {
			g.queue = nil
			ret := g.items
			g.items = nil
			return ret
		}
		fetchedCount += len(newBatch)
		g.items = append(g.items, newBatch...)
	}

	if fetchedCount > 0 {
		// We wait according to the limiter.
		// To reduce contention, we only wait once per call, and only if we fetched new items.
		err := g.limiter.WaitN(ctx, fetchedCount)
		if err != nil {
			logger.Warnf("rate limiter: %v", err)
		}
	}

	ret := g.items[:size]
	g.items = g.items[size:]
	return ret
}

// GenerateArray generates an array of items of the requested size given a generator.
func GenerateArray[G Generator[T], T any](g G, size int) []T {
	arr := make([]T, size)
	for i := range arr {
		arr[i] = g.Next()
	}
	return arr
}
